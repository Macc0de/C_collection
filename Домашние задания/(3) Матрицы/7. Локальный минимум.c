/*
Вводится размер матрицы(количество строк и столбцов) и ее элементы - целые числа.
Для заданной матрицы подсчитать и вывести количество локальных минимумов.

Элемент матрицы называется локальным минимумом, если он строго меньше всех своих четырёх соседей 
(или трёх, если этот элемент лежит на границе; или двух, если это угловой элемент и еще нужно учесть случаи, 
когда матрица состоит только из одной строки или столбца).

При решении задачи дополнительные массивы использовать нельзя.

Input:
3 3
0 1 0
1 1 1
0 1 0
Output:
4

Input:
3 5
0 1 0 1 0
1 0 1 0 1
0 1 0 1 0 
Output:
8

Input:
2 3
1 1 1
1 0 1
Output:
1
*/
#include <stdio.h>

int main()
{
	int N, M;
	scanf("%d %d", &N, &M);
	
	int A[N][M];
	int i, j;
	
	for(i = 0; i < N; i++)
	{
		for(j = 0; j < M; j++)
		{
			scanf("%d", &A[i][j]);
		}
	}
	
	int count = 0;
	for (i = 0; i < N; i++) 
	{
        for (j = 0; j < M; j++) 
		{
			// Только одна строка
			if(N == 1 && M > 1)
			{
				if(j != 0 && j != M-1) // Центр
				{
					if(A[i][j] < A[i][j-1] && A[i][j] < A[i][j+1])
						count++;
				}
				else if(j == 0) // Слева
				{
					if(A[i][j] < A[i][j+1])
						count++;
				}
				else if(j == M-1) // Справа
				{
					if(A[i][j] < A[i][j-1])
						count++;
				}
			}
			
			// Только один столбец
			else if(M == 1 && N > 1)
			{
				if(i != 0 && i != N-1) // Центр
				{
					if(A[i][j] < A[i-1][j] && A[i][j] < A[i+1][j])
						count++;
				}
				else if(i == 0) // Сверху
				{
					if(A[i][j] < A[i+1][j])
						count++;
				}
				else if(i == N-1) // Снизу
				{
					if(A[i][j] < A[i-1][j])
						count++;
				}
			}
			
			// Все центральный элементы:
			else if(M > 1 && N > 1 && i != 0 && i != N-1 && j != 0 && j != M-1) // Центр
			{
				if(A[i][j] < A[i][j-1] && A[i][j] < A[i-1][j] && A[i][j] < A[i][j+1] && A[i][j] < A[i+1][j])
					count++;
			}
			else if(M > 1 && N > 1 && i != 0 && i != N-1 && j == 0) // Центр слева
			{
				if(A[i][j] < A[i-1][j] && A[i][j] < A[i][j+1] && A[i][j] < A[i+1][j])
					count++;
			}
			else if(M > 1 && N > 1 && i == N-1 && j != 0 && j != M-1) // Центр снизу
			{
				if(A[i][j] < A[i][j-1] && A[i][j] < A[i][j+1] && A[i][j] < A[i-1][j])
					count++;
			}
			else if(M > 1 && N > 1 && i != 0 && i != N-1 && j == M-1) // Центр справа
			{
				if(A[i][j] < A[i][j-1] && A[i][j] < A[i-1][j] && A[i][j] < A[i+1][j])
					count++;
			}
			else if(M > 1 && N > 1 && i == 0 && j != 0 && j != M-1) // Центр сверху
			{
				if(A[i][j] < A[i][j-1] && A[i][j] < A[i][j+1] && A[i][j] < A[i+1][j])
					count++;
			}
			
			// Все элементы по бокам:
			else if(M > 1 && N > 1 && i == 0 && j == 0) // Слева сверху
			{
				if(A[i][j] < A[i+1][j] && A[i][j] < A[i][j+1])
					count++;
			}
			else if(M > 1 && N > 1 && i == N-1 && j == 0) // Слева снизу
			{
				if(A[i][j] < A[i-1][j] && A[i][j] < A[i][j+1])
					count++;
			}
			if(M > 1 && N > 1 && i == 0 && j == M-1) // Справа сверху
			{
				if(A[i][j] < A[i+1][j] && A[i][j] < A[i][j-1])
					count++;
			}
			else if(M > 1 && N > 1 && i == N-1 && j == M-1) // Справа снизу
			{
				if(A[i][j] < A[i][j-1] && A[i][j] < A[i-1][j])
					count++;
			}
		}
    }
	
	printf("%d", count);

	return 0;
}
