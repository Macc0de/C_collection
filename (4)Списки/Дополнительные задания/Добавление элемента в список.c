#include <stdio.h>
#include <stdlib.h>

struct List
{
	int data;
	struct List* Next; // Указатель на структуру List
} *First; // Создали переменную этого типпа данных // Указывает на пустоту

void addToList(struct List** head, int value) // Указатель на указатель на структуру(самое начало списка)
{
    struct List* new_node = malloc(sizeof(struct List)); // Указатель на структуру
	// Новый элемент
	
    new_node->data = value; // Иницилизируем value для созданного элемента
	// Обращаемся к полям текущего элемента
    new_node->Next = NULL; // Указывается, что этот узел будет последним в списке
	
    // Инициилизация головы списка
    if (*head == NULL) // Если список пустой, а изначально он пустой, поэтому надо указать голову списка
	{
        *head = new_node; // Указывает на выделенную память
        return;
    }

    struct List* current = *head; // Самый первый элемент
    while (current->Next != NULL)
	{
        current = current->Next;
    }
    current->Next = new_node;
	/*
	Таким образом, в момент выполнения `current->Next = new_node`, `new_node` хранит указатель на выделенную память, 
	где хранится новый узел списка, а не значение `NULL`. 
	`new_node` указывает на новый узел, который и будет добавлен в список.
	*/
	/* Указатель Next последнего элемента на новый узел new_node, добавляя его в конец списка.
	Добавление нового узла в конец списка. Новый узел является последним элементом, он должен быть связан с предыдущим
	последним элементом путем обновления его указателя Next на адрес нового указателя. Без этой операции, последний
	элемент списка будет указывать на NULL, что означало бы, что он конечный элемент списка, и добавление нового узла
	в конец списка не произошло бы, так как мы не имели бы ссылки на последний элемент, чтобы обновить его указатель Next */
}

int main()
{
	int i;
	int array[8];
	
	for (i = 0; i < 8; i++)
	{
		scanf("%d", &array[i]);
	}
	
	for (i = 0; i < 8; i++)
	{
		addToList(&First, array[i]);
	}
	
	struct List* current = First;
	while (current)
	{
		printf("%d ", current->data);
		current = current->Next;
	}
	
	return 0;
}
